#!/usr/bin/env perl

# THIS SCRIPT IS NOT INTENDED FOR END USERS OR FOR PEOPLE INSTALLING
# THE MODULES, BUT FOR THE AUTHOR'S USE WHEN UPDATING THE DATA FROM OFCOM'S
# PUBLISHED DATA.

use strict;
use warnings;
use XML::XPath;
use Spreadsheet::XLSX;
use Text::CSV_XS;
use Data::Dumper;local $Data::Dumper::Indent = 1;

use lib 'lib';
use Number::Phone::Country qw(noexport);

$| = 1;

my $csv = Text::CSV_XS->new({ binary => 1 });

open(MODULE, '>lib/Number/Phone/NANP/Data.pm') || die("Can't write lib/Number/Phone/NANP/Data.pm\n");

print MODULE "# automatically generated file, don't edit\n\n";
print MODULE q{

  # Copyright 2011 David Cantrell, derived from data from libphonenumber
  # http://code.google.com/p/libphonenumber/
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  # 
  #     http://www.apache.org/licenses/LICENSE-2.0
  # 
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  package Number::Phone::NANP::Data;

  use strict;
  use warnings;
  use vars qw(%areanames %fixed_line_regexes %mobile_regexes);
}.
"our \$VERSION = 1.".join("", (gmtime())[5] + 1900, sprintf('%02d', (gmtime())[4] + 1), map { sprintf('%02d', $_) } (gmtime())[3, 2, 1, 0]).";\n\n".q{

  sub _prefixes {
      my $number = shift;
      map { substr($number, 0, $_) } reverse(1..length($number));
  }

  sub _areaname {
    my $number = shift;
    foreach my $prefix (_prefixes($number)) {
      if(exists($areanames{$prefix})) { return $areanames{$prefix} };
    }
    return undef;
  }
};

# Extract area names
print MODULE '%areanames = (';
open(LIBPHONENUMBERDATA, 'libphonenumber/resources/geocoding/en/1.txt') || die("Can't read libphonenumber/resources/geocoding/en/1.txt\n");
my @lines = <LIBPHONENUMBERDATA>;
close(LIBPHONENUMBERDATA);
foreach my $line (@lines) {
  chomp($line);
  next if($line =~ /^(#.*|\s+)?$/);
  my($prefix, $area) = split(/\|/, $line);
  $area = quotemeta($area);
  print MODULE "    '$prefix' => \"$area\",\n";
}
print MODULE '  );';

# despite this data being in libphonenumber, it's only useful for
# some countries. eg it looks sane for JM but not for CA
# they list +1 204 as being both fixed line and mobile. Grargh!
# # extract mobile/fixed-line prefix regexes
my $xml = XML::XPath->new(filename => 'libphonenumber/resources/PhoneNumberMetadata.xml');
my @territories = $xml->find('/phoneNumberMetadata/territories/territory')->get_nodelist();
TERRITORY: foreach my $territory (@territories) {
    next TERRITORY unless($territory->find('@countryCode').'' eq '1');
    (my $fixed  = $territory->find("fixedLine/nationalNumberPattern")->string_value()) =~ s/\s+//g;
    (my $mobile = $territory->find("mobile/nationalNumberPattern")->string_value()) =~ s/\s+//g;
    my $ISO_country_code = $territory->find('@id').'';
    if($fixed eq $mobile) {
        warn("$ISO_country_code: same regexes for fixed and mobile\n");
        next TERRITORY;
    } else {
        my @area_codes = Number::Phone::Country::_NANP_area_codes($ISO_country_code);
        foreach my $area_code (@area_codes) {
            foreach my $co (map { sprintf("%03d", $_ ) } 0 .. 999) {
                my $number = "${area_code}${co}3333";
                if($number =~ /^$fixed$/x && $number =~ /^$mobile$/x) {
                    warn("$ISO_country_code: Overlap between fixed/mobile regexes for $number; can't be trusted\n");
                    next TERRITORY;
                }
            }
        }
    }
    warn("$ISO_country_code: good data to tell what's fixed/mobile\n");
    print MODULE "\$fixed_line_regexes{$ISO_country_code} = '$fixed';\n";
    print MODULE "\$mobile_regexes{$ISO_country_code} = '$mobile';\n";
}

warn("Extracting Canadian operators\n");
open(my $operators, '<', 'COCodeStatus_ALL.csv') ||
    die("Couldn't open COCodeStatus_ALL.csv: $!\n");
$csv->getline($operators); # header line
$csv->getline($operators); # date stamp?
mkdir('share');
unlink('share/Number-Phone-NANP-Data.db');

# file format:
# first a list of 32-bit pointers, one for each 10,000 number
# block NPA-NXX-xxxx, starting at 200-000. So the address of
# the pointer is 4 * (NPA - 200000).
#
# pointers point at various structures identified by their leading
# byte, with the NULL pointer meaning "no data":
#
# 0: length byte then string
# 1: block of 10 pointers, one for each thousand number block in
#    an NPA-NXX-X

open(my $randomfh, "> :raw :bytes", 'share/Number-Phone-NANP-Data.db') || die($!);
while(my $row = $csv->getline($operators)) {
    last unless($row->[0]);
    next unless($row->[2]);
    my($co, $op) = (join('', $row->[0], $row->[1]), $row->[2]);
    _write_operator_data($co, $op);
}
warn("Extracting US operators\n");
foreach my $file (map { "${_}Codes.xlsx" } qw(Est Cen Wst)) {
    warn("$file\n");
    my $excel = Spreadsheet::XLSX->new($file);
    SHEET: foreach my $sheet (@{$excel->{Worksheet}}) {
        next SHEET unless($sheet->{Name} =~ /^..$/);
        warn("  ".$sheet->{Name}."\n");
        ROW: foreach my $row ($sheet->{MinRow} + 3 .. $sheet->{MaxRow}) {
            my($co, $use, $op) = map {
                $sheet->{Cells}->[$row]->[$_]->{Val}
            } ($sheet->{MinCol}, $sheet->{MinCol} + 1, $sheet->{MinCol} + 3);
            next ROW if(!$op || $use ne 'AS'); # Assigned
            $co =~ s/\D//g;
            if(!$op) { warn("CO $co has no operator\n"); next ROW }
            _write_operator_data($co, $op);
        }
    }
}

my %seen_operators;
my $next_data_offset;
sub _write_operator_data {
    my($co, $op) = @_;
    $co -= 200000; # area codes 000 to 199 are invalid
    $next_data_offset ||= 5 * 799999;
    seek($randomfh, 4 * $co, 0);
    if(exists($seen_operators{$op})) {
        print $randomfh pack('N', $seen_operators{$op});
    } else {
        print $randomfh pack('N', $next_data_offset);
        seek($randomfh, $next_data_offset, 0);
        die("Operator '$op' is longer than 255 bytes\n")
            if(length($op) > 255);
        print $randomfh pack('CCA*', 0, length($op), $op);
        $seen_operators{$op} = $next_data_offset;
        $next_data_offset += length($op) + 2;
    }
}

close(MODULE);
