#!/usr/bin/env perl

# THIS SCRIPT IS NOT INTENDED FOR END USERS OR FOR PEOPLE INSTALLING
# THE MODULES, BUT FOR THE AUTHOR'S USE WHEN UPDATING THE DATA FROM OFCOM'S
# PUBLISHED DATA.

use strict;
use warnings;
use XML::XPath;
use Text::CSV_XS;
use Data::Dumper;local $Data::Dumper::Indent = 1;

use lib 'lib';
use Number::Phone::Country qw(noexport);

$| = 1;

my $csv = Text::CSV_XS->new({ binary => 1 });

open(MODULE, '>lib/Number/Phone/NANP/Data.pm') || die("Can't write lib/Number/Phone/NANP/Data.pm\n");

print MODULE "# automatically generated file, don't edit\n\n";
print MODULE q{

  # Copyright 2011 David Cantrell, derived from data from libphonenumber
  # http://code.google.com/p/libphonenumber/
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  # 
  #     http://www.apache.org/licenses/LICENSE-2.0
  # 
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  package Number::Phone::NANP::Data;

  use strict;
  use warnings;
  use vars qw(%areanames %fixed_line_regexes %mobile_regexes);
}.
"our \$VERSION = 1.".join("", (gmtime())[5] + 1900, sprintf('%02d', (gmtime())[4] + 1), map { sprintf('%02d', $_) } (gmtime())[3, 2, 1, 0]).";\n\n".q{

  sub _prefixes {
      my $number = shift;
      map { substr($number, 0, $_) } reverse(1..length($number));
  }

  sub _areaname {
    my $number = shift;
    foreach my $prefix (_prefixes($number)) {
      if(exists($areanames{$prefix})) { return $areanames{$prefix} };
    }
    return undef;
  }
};

# Extract area names
print MODULE '%areanames = (';
open(LIBPHONENUMBERDATA, 'libphonenumber/resources/geocoding/en/1.txt') || die("Can't read libphonenumber/resources/geocoding/en/1.txt\n");
my @lines = <LIBPHONENUMBERDATA>;
close(LIBPHONENUMBERDATA);
foreach my $line (@lines) {
  chomp($line);
  next if($line =~ /^(#.*|\s+)?$/);
  my($prefix, $area) = split(/\|/, $line);
  $area = quotemeta($area);
  print MODULE "    '$prefix' => \"$area\",\n";
}
print MODULE '  );';

# despite this data being in libphonenumber, it's only useful for
# some countries. eg it looks sane for JM but not for CA
# they list +1 204 as being both fixed line and mobile. Grargh!
# # extract mobile/fixed-line prefix regexes
my $xml = XML::XPath->new(filename => 'libphonenumber/resources/PhoneNumberMetadata.xml');
my @territories = $xml->find('/phoneNumberMetadata/territories/territory')->get_nodelist();
TERRITORY: foreach my $territory (@territories) {
    next TERRITORY unless($territory->find('@countryCode').'' eq '1');
    (my $fixed  = $territory->find("fixedLine/nationalNumberPattern")->string_value()) =~ s/\s+//g;
    (my $mobile = $territory->find("mobile/nationalNumberPattern")->string_value()) =~ s/\s+//g;
    my $ISO_country_code = $territory->find('@id').'';
    if($fixed eq $mobile) {
        warn("$ISO_country_code: same regexes for fixed and mobile\n");
        next TERRITORY;
    } else {
        my @area_codes = Number::Phone::Country::_NANP_area_codes($ISO_country_code);
        foreach my $area_code (@area_codes) {
            foreach my $co (map { sprintf("%03d", $_ ) } 0 .. 999) {
                my $number = "${area_code}${co}3333";
                if($number =~ /^$fixed$/x && $number =~ /^$mobile$/x) {
                    warn("$ISO_country_code: Overlap between fixed/mobile regexes for $number; can't be trusted\n");
                    next TERRITORY;
                }
            }
        }
    }
    warn("$ISO_country_code: good data to tell what's fixed/mobile\n");
    print MODULE "\$fixed_line_regexes{$ISO_country_code} = '$fixed';\n";
    print MODULE "\$mobile_regexes{$ISO_country_code} = '$mobile';\n";
}

my $WORDLENGTH = 4;
# file format:
# first a list of $WORDLENGTH byte pointers, one for each 10,000 number
# block NPA-NXX-xxxx, starting at 200-000. So the address of
# the pointer is $WORDLENGTH * (NPANXX - 200000).
#
# pointers point at various structures identified by their leading
# byte, with the NULL pointer meaning "no data":
#
# 0: length byte then string
# 1: block of 10 pointers, one for each thousand number block in
#    an NPA-NXX-X
my %seen_operators = ();
my $next_data_offset = $WORDLENGTH * 800000;

mkdir('share');
unlink('share/Number-Phone-NANP-Data.db');
open(my $randomfh, "> :raw :bytes", 'share/Number-Phone-NANP-Data.db') || die($!);

warn("Extracting Canadian operators\n");
open(my $CA_operators, '<', 'COCodeStatus_ALL.csv') ||
    die("Couldn't open COCodeStatus_ALL.csv: $!\n");
$csv->getline($CA_operators); # header line
$csv->getline($CA_operators); # date stamp?
while(my $row = $csv->getline($CA_operators)) {
    last unless($row->[0]);
    next unless($row->[2]);
    my($co, $op) = (join('', $row->[0], $row->[1]), $row->[2]);
    _write_operator_data($co, $op);
}

warn("Extracting US operators\n");
open(my $US_operators, '<', 'AllBlocksAugmentedReport.txt') ||
    die("Couldn't open AllBlocksAugmentedReport.txt: $!\n");
$csv->getline($US_operators); # header line
my %US = ();
while(my $row = $csv->getline($US_operators)) {
    my($npa, $nxx, $thousands, $status, $op) = map { $row->[$_] } (2, 3, 4, 5, 12);
    next unless($status eq 'AS');
    $US{"$npa$nxx"} ||= [];
    push @{$US{"$npa$nxx"}}, { thousands => $thousands, op => $op }
}

foreach my $npanxx (keys %US) {
    my $data = $US{$npanxx};
    if(
        $#{$data} == 9 && # got 10 assigned blocks
        scalar(keys(%{{
            map { $data->[$_]->{op} => 1 } (0 .. 9)
        }})) == 1 # but only one operator
    ) {
        # print "$npanxx is a ten-thousands block\n";
        _write_operator_data($npanxx, $data->[0]->{op});
    } else {
        # if we get here the block is sub-divided
        _write_multiple_operators($npanxx, $data);
    }
}

sub _write_operator_data {
    my($co, $op) = @_;
    # area codes 000 to 199 are invalid
    seek($randomfh, $WORDLENGTH * ($co - 200000), 0);
    if(exists($seen_operators{$op})) {
        print $randomfh pack('N', $seen_operators{$op});
    } else {
        print $randomfh pack('N', $next_data_offset);
        seek($randomfh, $next_data_offset, 0);
        die("Operator '$op' is longer than 255 bytes\n")
            if(length($op) > 255);
        print $randomfh pack('CCA*', 0, length($op), $op);
        $seen_operators{$op} = $next_data_offset;
        $next_data_offset += length($op) + 2;
    }
}

sub _write_multiple_operators {
    my($co, $data) = @_;
    seek($randomfh, $WORDLENGTH * ($co - 200000), 0);
    print $randomfh pack('N', $next_data_offset);
    seek($randomfh, $next_data_offset, 0);
    print $randomfh pack('C', 1); # block-type marker
    $next_data_offset++;
    # the array might have less than 10 entries, eg
    # [
    #   { thousands => 3, op => "blah",      pointer => ... },
    #   { thousands => 7, op => "otherblah", pointer => ... },
    #   { thousands => 9, op => "blah",      pointer => ... },
    # ]
    # but the array of pointers in the file is always ten entries
    my $start_of_pointers = $next_data_offset;
    $next_data_offset += $WORDLENGTH * 10;

    foreach my $index (0 .. $#{$data}) {
        my($thousands_digit, $op) = map { $data->[$index]->{$_} } qw(thousands op);

        seek($randomfh, $start_of_pointers + $WORDLENGTH * $thousands_digit, 0);
        if(exists($seen_operators{$op})) {
            print $randomfh pack('N', $seen_operators{$op});
        } else {
            print $randomfh pack('N', $next_data_offset);
            seek($randomfh, $next_data_offset, 0);
            die("Operator '$op' is longer than 255 bytes\n")
                if(length($op) > 255);
            print $randomfh pack('CCA*', 0, length($op), $op);
            $seen_operators{$op} = $next_data_offset;
            $next_data_offset += length($op) + 2;
        }
    }
}

close(MODULE);
